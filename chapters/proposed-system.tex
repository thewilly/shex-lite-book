\chapter{Proposed Translator}
\label{ch:proposed-system}
As a solution to the previous chapter, this one focuses on proposing a function $f$ such that applied on a
schema, defined in \cref{eq:schema-formalization}, results in a domain model based on plain objects,
defined in \cref{eq:plain-object-model}. Therefore the aim of this chapter is to once defined an schema as,

\begin{equation}
schema\ =\begin{bmatrix}shape_1=\{(p_{11},t_{11},c_{11}),\ (p_{21},t_{21},c_{21}),\ \dots,\ (p_{31},t_{31},c_{31})\}
\\ shape_2=\{(p_{12},t_{12},c_{12}),\ (p_{22},t_{22},c_{22}),\ \dots,\ (p_{32},t_{32},c_{32})\}
\\ \vdots
\\ shape_n=\{(p_{nm},t_{nm},c_{nm}),\ (p_{nm},t_{nm},c_{nm}),\ \dots,\ (p_{nm},t_{nm},c_{nm})\}
\end{bmatrix}
\end{equation}

and the function $f$,

\begin{equation}
f(schema)\rightarrow
\begin{bmatrix}f'(shape_1)
\\ f'(shape_2)
\\ \vdots
\\ f'(shape_n)
\end{bmatrix}
=\ plain\ object\ model
\end{equation}

that maps and schema to a plain object model, being $f'(x)$ defined as,

\begin{equation}
	f'(p_n,t_n,c_n) \rightarrow (p'_n,t'_n)
\end{equation}

where \cref{eq:constraint} is applied. Give a proposition for $f'(x')$ and therefore for $f(x)$.

For this, in this section we will see the structure of the proposed solution as well as an implementation
that allows us to validate the proposed solution to later analyze the objects generated by the solution.

\section{Structure}
At the very end a code translator is a kind of compiler where you should have a front-end, that
analyzes the input source code and checks that everything is correct, and a back-end that
generates the code in the target language. The main difference between generating code encoded
in a single language or in multiple languages is the number of specific translators that you will need to
implement, but all of them will be grouped in the bac-end. Therefore we will separate our
translator in \textbf{front-end} and \textbf{back-end}.

\subsection{Front-end}
The front-end task is to parse, analyze and validate the input source code. This might seem familiar to
\cref{ch:proposed-sintactic-semantic-analyzer} and it is in fack because in that chapter we define
a compiler front-end. Therefore we will re-use the same backend and we will continue to develope this
chapter from the \textit{Intermediate Language} that was generated at the end of the process described in
\cref{fig:shex-lite-sema}.

\subsection{Back-end}
The back-end of a translator, also known as the \textit{sinthesis} takes the previous \textit{Intermediate Language}
and translates it to the desired target language. \cref{fig:translation-function} illustrates this process.

\begin{figure}
    \includegraphics{images/translation-function.pdf}
    \centering
	\caption[Generic translation function structure]{Generic translation function structure for multiple
	target languages.}
    \label{fig:translation-function}
\end{figure}

\section{Implementation}

\section{Generated Obejcts}

\begin{figure}
    \includegraphics[width=\textwidth]{images/shex-lite-syntaxes-mental-model.png}
    \centering
    \caption[Mental model of ShEx-Lite in the existing ShEx syntaxes context.]{Mental model of
    ShEx-Lite in the existing ShEx syntaxes context. From this model we can see that Shex-Lite
    is in fact an strictly subset of ShExC, which follows the ShEx Specification. And therefore
    ShEx-Lite will also follow that expecification, which automatically enables ShEx-Lite schemas
    to be used in any other existing ShEx tool.}
    \label{fig:syntax-mental-model}
\end{figure}

\begin{figure}
  \includegraphics[width=\textwidth]{images/shex-lite-constraints-context.png}
  \centering
  \caption[Constraints and checks context diagram for ShEx-Lite and ShEx.]{Constraints
  and checks context diagram for ShEx-Lite and ShEx.}
  \label{fig:constraints-context}
\end{figure}

\begin{center}
	\noindent\begin{minipage}[t]{.4\textwidth}
		\begin{lstlisting}[frame=topline,numbers=left,title=\scriptsize\texttt{Person.shexl}, basicstyle=\ttfamily\scriptsize]{a}
# Prefixes...
:Person {
	:name xsd:string ;
	:knows @:Person *
}
		\end{lstlisting}
	\end{minipage}\hfill
	\begin{minipage}[t]{.5\textwidth}
		\begin{lstlisting}[language=Java, frame=t,numbers=left,title=\scriptsize\texttt{Person.java}, basicstyle=\ttfamily\scriptsize]{b}
// Imports...
public class Person {
	private String name;
	private List<Person> knows;
	// Constructor...
	// Getters and Setters...
}
		\end{lstlisting}
	\end{minipage}
	\captionof{figure}{Schema modeling a \texttt{Person} in \texttt{shexl} syntax to the left. And the \texttt{ShEx-Lite} generated code in \texttt{Java} to the right.}
	\label{fig:example-1}
\end{center}