@article{linked-data,
	title={Linked data: Evolving the web into a global data space},
	author={Heath, Tom and Bizer, Christian},
	journal={Synthesis lectures on the semantic web: theory and technology},
	volume={1},
	number={1},
	pages={1--136},
	year={2011},
	publisher={Morgan \& Claypool Publishers}
}

@article{oslc-resource-shape,
	title={OSLC Resource Shape: A language for defining constraints on Linked Data.},
	author={Ryman, Arthur G and Le Hors, Arnaud and Speicher, Steve},
	journal={LDOW},
	volume={996},
	year={2013},
	publisher={Citeseer}
}

@article{ll-parsing,
	title={Adaptive LL (*) parsing: the power of dynamic analysis},
	author={Parr, Terence and Harwell, Sam and Fisher, Kathleen},
	journal={ACM SIGPLAN Notices},
	volume={49},
	number={10},
	pages={579--598},
	year={2014},
	publisher={ACM New York, NY, USA}
}

@inproceedings{iovka-shex-for-rdf,
	title={Complexity and Expressiveness of ShEx for RDF},
	author={Staworko, Slawomir and Boneva, Iovka and Gayo, Jose Emilio Labra and Hym, Samuel and Prud'Hommeaux, Eric Gordon and Solbrig, Harold},
	year={2015}
}

@article{iovka-auto-shex-shacl,
	title={Semi Automatic Construction of ShEx and SHACL Schemas},
	author={Boneva, Iovka and Dusart, J{\'e}r{\'e}mie and Alvarez, Daniel Fern{\'a}ndez and Gayo, Jose Emilio Labra},
	year={2019}
}

@article{labra-validating-rdf,
	title={Validating RDF data},
	author={Labra Gayo, Jose Emilio and Prud'Hommeaux, Eric and Boneva, Iovka and Kontokostas, Dimitris},
	journal={Synthesis Lectures on Semantic Web: Theory and Technology},
	volume={7},
	number={1},
	pages={1--328},
	year={2017},
	publisher={Morgan \& Claypool Publishers}
}

@article{shexml,
	title={ShExML: An heterogeneous data mapping language based on ShEx},
	author={Garcia-Gonzalez, Herminio and Fernandez-Alvarez, Daniel and Emilio, Jose}
}

@incollection{rdf-challenges,
	title={Challenges in RDF validation},
	author={Labra-Gayo, Jose Emilio and Garc{\'\i}a-Gonz{\'a}lez, Herminio and Fern{\'a}ndez-Alvarez, Daniel and Prud’hommeaux, Eric},
	booktitle={Current Trends in Semantic Web Technologies: Theory and Practice},
	pages={121--151},
	year={2019},
	publisher={Springer}
}

@inproceedings{shapes-schemas-rdf,
	title={Semantics and validation of shapes schemas for RDF},
	author={Boneva, Iovka and Gayo, Jose E Labra and Prud’hommeaux, Eric G},
	booktitle={International Semantic Web Conference},
	pages={104--120},
	year={2017},
	organization={Springer}
}

@inproceedings{eric-rdf-validation-lang,
	title={Shape expressions: an RDF validation and transformation language},
	author={Prud'hommeaux, Eric and Labra Gayo, Jose Emilio and Solbrig, Harold},
	booktitle={Proceedings of the 10th International Conference on Semantic Systems},
	pages={32--40},
	year={2014}
}

@misc{w3c-www-design-issues,
	File = {Design Issues for the World Wide Web:/Users/willy/Zotero/storage/6CSP3ZCZ/DesignIssues.html:text/html},
	Title = {Design {Issues} for the {World} {Wide} {Web}},
	Url = {https://www.w3.org/DesignIssues/},
	Urldate = {2020-05-25},
	Bdsk-Url-1 = {https://www.w3.org/DesignIssues/}
}

@misc{dsl,
	Abstract = {A domain-specific language (DSL) is a computer language specialized to a particular application domain. This is in contrast to a general-purpose language (GPL), which is broadly applicable across domains. There are a wide variety of DSLs, ranging from widely used languages for common domains, such as HTML for web pages, down to languages used by only one or a few pieces of software, such as MUSH soft code. DSLs can be further subdivided by the kind of language, and include domain-specific markup languages, domain-specific modeling languages (more generally, specification languages), and domain-specific programming languages. Special-purpose computer languages have always existed in the computer age, but the term "domain-specific language" has become more popular due to the rise of domain-specific modeling. Simpler DSLs, particularly ones used by a single application, are sometimes informally called mini-languages.
	The line between general-purpose languages and domain-specific languages is not always sharp, as a language may have specialized features for a particular domain but be applicable more broadly, or conversely may in principle be capable of broad application but in practice used primarily for a specific domain. For example, Perl was originally developed as a text-processing and glue language, for the same domain as AWK and shell scripts, but was mostly used as a general-purpose programming language later on. By contrast, PostScript is a Turing complete language, and in principle can be used for any task, but in practice is narrowly used as a page description language.},
	Copyright = {Creative Commons Attribution-ShareAlike License},
	File = {Snapshot:/Users/willy/Zotero/storage/98ZI3TUU/index.html:text/html},
	Journal = {Wikipedia},
	Language = {en},
	Month = mar,
	Note = {Page Version ID: 945660040},
	Title = {Domain-specific language},
	Url = {https://en.wikipedia.org/w/index.php?title=Domain-specific_language&oldid=945660040},
	Urldate = {2020-05-26},
	Year = {2020},
	Bdsk-Url-1 = {https://en.wikipedia.org/w/index.php?title=Domain-specific_language&oldid=945660040}
}

@misc{dotNet,
	Abstract = {The Roslyn .NET compiler provides C\# and Visual Basic languages with rich code analysis APIs. - dotnet/roslyn},
	File = {Snapshot:/Users/willy/Zotero/storage/47SCIQXZ/Roslyn Overview.html:text/html},
	Journal = {GitHub},
	Language = {en},
	Note = {Library Catalog: github.com},
	Title = {dotnet/roslyn},
	Url = {https://github.com/dotnet/roslyn},
	Urldate = {2020-05-24},
	Bdsk-Url-1 = {https://github.com/dotnet/roslyn}
}

@misc{ide,
	Abstract = {Un entorno de desarrollo integrado[1]​[2]​ o entorno de desarrollo interactivo, en ingl{\'e}s Integrated Development Environment (IDE), es una aplicaci{\'o}n inform{\'a}tica que proporciona servicios integrales para facilitarle al desarrollador o programador el desarrollo de software.
	Normalmente, un IDE consiste de un editor de c{\'o}digo fuente, herramientas de construcci{\'o}n autom{\'a}ticas y un depurador. La mayor{\'\i}a de los IDE tienen auto-completado inteligente de c{\'o}digo (IntelliSense). Algunos IDE contienen un compilador, un int{\'e}rprete, o ambos, tales como NetBeans y Eclipse; otros no, tales como SharpDevelop y Lazarus.
	El l{\'\i}mite entre un IDE y otras partes del entorno de desarrollo de software m{\'a}s amplio no est{\'a} bien definido. Muchas veces, a los efectos de simplificar la construcci{\'o}n de la interfaz gr{\'a}fica de usuario (GUI, por sus siglas en ingl{\'e}s) se integran un sistema controlador de versi{\'o}n y varias herramientas. Muchos IDE modernos tambi{\'e}n cuentan con un navegador de clases, un buscador de objetos y un diagrama de jerarqu{\'\i}a de clases, para su uso con el desarrollo de software orientado a objetos.},
	Copyright = {Creative Commons Attribution-ShareAlike License},
	File = {Snapshot:/Users/willy/Zotero/storage/TRB6LMBJ/index.html:text/html},
	Journal = {Wikipedia, la enciclopedia libre},
	Language = {es},
	Month = may,
	Note = {Page Version ID: 126109294},
	Title = {Entorno de desarrollo integrado},
	Url = {https://es.wikipedia.org/w/index.php?title=Entorno_de_desarrollo_integrado&oldid=126109294},
	Urldate = {2020-05-26},
	Year = {2020},
	Bdsk-Url-1 = {https://es.wikipedia.org/w/index.php?title=Entorno_de_desarrollo_integrado&oldid=126109294}
}

@misc{hercules-um,
	Abstract = {Inicio - H{\'e}rcules - Universidad de Murcia},
	File = {Snapshot:/Users/willy/Zotero/storage/T8RSVLBG/hercules.html:text/html},
	Language = {es-ES},
	Note = {Library Catalog: www.um.es},
	Title = {H{\'e}rcules - {Universidad} de {Murcia}},
	Url = {https://www.um.es/web/hercules/},
	Urldate = {2020-05-25},
	Bdsk-Url-1 = {https://www.um.es/web/hercules/}
}

@misc{lexical-analysis,
	Abstract = {In computer science, lexical analysis, lexing or tokenization is the process of converting a sequence of characters (such as in a computer program or web page) into a sequence of tokens (strings with an assigned and thus identified meaning). A program that performs lexical analysis may be termed a lexer, tokenizer, or scanner, though scanner is also a term for the first stage of a lexer. A lexer is generally combined with a parser, which together analyze the syntax of programming languages, web pages, and so forth.},
	Copyright = {Creative Commons Attribution-ShareAlike License},
	File = {Snapshot:/Users/willy/Zotero/storage/ULAQDI4N/index.html:text/html},
	Journal = {Wikipedia},
	Language = {en},
	Month = may,
	Note = {Page Version ID: 955735363},
	Title = {Lexical analysis},
	Url = {https://en.wikipedia.org/w/index.php?title=Lexical_analysis&oldid=955735363},
	Urldate = {2020-05-26},
	Year = {2020},
	Bdsk-Url-1 = {https://en.wikipedia.org/w/index.php?title=Lexical_analysis&oldid=955735363}
}

@misc{oopl,
	Abstract = {This is a list of notable programming languages with object-oriented programming (OOP) features, which are also listed in Category:Object-oriented programming languages. Note that, in some contexts, the definition of an "object-oriented programming language" is not exactly the same as that of a "programming language with object-oriented features". For example, C++ is a multi-paradigm language including object-oriented paradigm; however, it is less object-oriented than some other languages such as Python and Ruby. Therefore, someone considers C++ as an OOP language, while others do not or prefer to name it as "semi-object-oriented programming language".},
	Copyright = {Creative Commons Attribution-ShareAlike License},
	File = {Snapshot:/Users/willy/Zotero/storage/F2ZKIHES/index.html:text/html},
	Journal = {Wikipedia},
	Language = {en},
	Month = apr,
	Note = {Page Version ID: 950660258},
	Title = {List of object-oriented programming languages},
	Url = {https://en.wikipedia.org/w/index.php?title=List_of_object-oriented_programming_languages&oldid=950660258},
	Urldate = {2020-05-25},
	Year = {2020},
	Bdsk-Url-1 = {https://en.wikipedia.org/w/index.php?title=List_of_object-oriented_programming_languages&oldid=950660258}
}

@misc{compiler-optimizations,
	Abstract = {In computing, an optimizing compiler is a compiler that tries to minimize or maximize some attributes of an executable computer program. Common requirements are to minimize a program's execution time, memory requirement, and power consumption (the last two being popular for portable computers).
	Compiler optimization is generally implemented using a sequence of optimizing transformations, algorithms which take a program and transform it to produce a semantically equivalent output program that uses fewer resources and/or executes faster. It has been shown that some code optimization problems are NP-complete, or even undecidable. In practice, factors such as the programmer's willingness to wait for the compiler to complete its task place upper limits on the optimizations that a compiler implementer might provide. (Optimization is generally a very CPU- and memory-intensive process.) In the past, computer memory limitations were also a major factor in limiting which optimizations could be performed. Because of these factors, optimization rarely produces "optimal" output in any sense, and in fact, an "optimization" may impede performance in some cases; rather, they are heuristic methods for improving resource usage in typical programs.},
	Copyright = {Creative Commons Attribution-ShareAlike License},
	File = {Snapshot:/Users/willy/Zotero/storage/TZDR9WT8/index.html:text/html},
	Journal = {Wikipedia},
	Language = {en},
	Month = apr,
	Note = {Page Version ID: 949660274},
	Title = {Optimizing compiler},
	Url = {https://en.wikipedia.org/w/index.php?title=Optimizing_compiler&oldid=949660274},
	Urldate = {2020-05-26},
	Year = {2020},
	Bdsk-Url-1 = {https://en.wikipedia.org/w/index.php?title=Optimizing_compiler&oldid=949660274}
}

@misc{pojo,
	Abstract = {Un POJO (acr{\'o}nimo de Plain Old Java Object) es una sigla creada por Martin Fowler, Rebecca Parsons y Josh MacKenzie en septiembre de 2000 y utilizada por programadores Java para enfatizar el uso de clases simples y que no dependen de un framework en especial. Este acr{\'o}nimo surge como una reacci{\'o}n en el mundo Java a los frameworks cada vez m{\'a}s complejos, y que requieren un complicado andamiaje que esconde el problema que realmente se est{\'a} modelando. En particular surge en oposici{\'o}n al modelo planteado por los est{\'a}ndares EJB anteriores al 3.0, en los que los "Enterprise JavaBeans" deb{\'\i}an implementar interfaces especiales.
	POJO es una nueva palabra para designar algo viejo, tan viejo como una tarjeta perforada. No existe en Java una nueva tecnolog{\'\i}a con ese nombre, sino que el nombre existe en el marco de una revalorizaci{\'o}n de la programaci{\'o}n "simplemente orientada a objetos". Esta revalorizaci{\'o}n tiene que ver tambi{\'e}n con el {\'e}xito de lenguajes orientados a objetos m{\'a}s puros[cita requerida] y sencillos, que empezaron a tomar parte del mercado al que Java apunta, como Ruby y Python.
	Un objeto POJO es una instancia de una clase que no extiende ni implementa nada en especial. Por ejemplo, un Servlet tiene que extender de HttpServlet y sobrescribir sus m{\'e}todos, por lo tanto no es un POJO. En cambio, si se define una clase 'Persona', con sus atributos privados y sus correspondientes getters y setters p{\'u}blicos, una instancia de esta simple clase es un objeto POJO.
	El t{\'e}rmino sigue la l{\'\i}nea de otras siglas similares, como POTS (Plain Old Telephone System) o PODS (Plain Old Data Structures) utilizada para describir a simples "struct" en el contexto de la programaci{\'o}n C++.
	Con el auge de JSON se utilizan  POJO para serializar los objetos en formato json, con bibliotecas como Gson.},
	Copyright = {Creative Commons Attribution-ShareAlike License},
	File = {Snapshot:/Users/willy/Zotero/storage/IA895AHG/index.html:text/html},
	Journal = {Wikipedia, la enciclopedia libre},
	Language = {es},
	Month = oct,
	Note = {Page Version ID: 120228634},
	Title = {Plain {Old} {Java} {Object}},
	Url = {https://es.wikipedia.org/w/index.php?title=Plain_Old_Java_Object&oldid=120228634},
	Urldate = {2020-05-25},
	Year = {2019},
	Bdsk-Url-1 = {https://es.wikipedia.org/w/index.php?title=Plain_Old_Java_Object&oldid=120228634}
}

@misc{programing-language,
	Abstract = {A programming language is a formal language comprising a set of instructions that produce various kinds of output. Programming languages are used in computer programming to implement algorithms.
	Most programming languages consist of instructions for computers. There are programmable machines that use a set of specific instructions, rather than general programming languages. Early ones preceded the invention of the digital computer, the first probably being the automatic flute player described in the 9th century by the brothers Musa in Baghdad, during the Islamic Golden Age. Since the early 1800s, programs have been used to direct the behavior of machines such as Jacquard looms, music boxes and player pianos. The programs for these machines (such as a player piano's scrolls) did not produce different behavior in response to different inputs or conditions.
	Thousands of different programming languages have been created, and more are being created every year. Many programming languages are written in an imperative form (i.e., as a sequence of operations to perform) while other languages use the declarative form (i.e. the desired result is specified, not how to achieve it).
	The description of a programming language is usually split into the two components of syntax (form) and semantics (meaning). Some languages are defined by a specification document (for example, the C programming language is specified by an ISO Standard) while other languages (such as Perl) have a dominant implementation that is treated as a reference. Some languages have both, with the basic language defined by a standard and extensions taken from the dominant implementation being common.},
	Copyright = {Creative Commons Attribution-ShareAlike License},
	File = {Snapshot:/Users/willy/Zotero/storage/4B6WS8RG/index.html:text/html},
	Journal = {Wikipedia},
	Language = {en},
	Month = may,
	Note = {Page Version ID: 958722580},
	Title = {Programming language},
	Url = {https://en.wikipedia.org/w/index.php?title=Programming_language&oldid=958722580},
	Urldate = {2020-05-26},
	Year = {2020},
	Bdsk-Url-1 = {https://en.wikipedia.org/w/index.php?title=Programming_language&oldid=958722580}
}

@misc{rdf,
	File = {RDF - Semantic Web Standards:/Users/willy/Zotero/storage/VUE4Y7LQ/RDF.html:text/html},
	Title = {{RDF} - {Semantic} {Web} {Standards}},
	Url = {https://www.w3.org/RDF/},
	Urldate = {2020-05-25},
	Bdsk-Url-1 = {https://www.w3.org/RDF/}
}

@article{rdf-primer,
	title={RDF primer},
	author={Manola, Frank and Miller, Eric and McBride, Brian and others},
	journal={W3C recommendation},
	volume={10},
	number={1-107},
	pages={6},
	year={2004}
}

@misc{rdfshape,
	File = {RDFShape:/Users/willy/Zotero/storage/RRH49HMY/rdfshape.weso.es.html:text/html},
	Title = {{RDFShape}},
	Url = {http://rdfshape.weso.es/},
	Urldate = {2020-05-24},
	Bdsk-Url-1 = {http://rdfshape.weso.es/}
}

@misc{shaclex,
	File = {SHaclEX library:/Users/willy/Zotero/storage/N3I3GV5M/shaclex.html:text/html},
	Title = {{SHaclEX} library},
	Url = {http://www.weso.es/shaclex/},
	Urldate = {2020-05-25},
	Bdsk-Url-1 = {http://www.weso.es/shaclex/}
}

@misc{shexc,
	File = {Shape Expressions Language 2.1:/Users/willy/Zotero/storage/72V49RPF/shex-semantics.html:text/html},
	Title = {Shape {Expressions} {Language} 2.1},
	Url = {https://shex.io/shex-semantics/#shexc},
	Urldate = {2020-05-23},
	Bdsk-Url-1 = {https://shex.io/shex-semantics/#shexc}
}

@misc{sparql,
	File = {SPARQL Query Language for RDF:/Users/willy/Zotero/storage/UAD2FNBL/rdf-sparql-query.html:text/html},
	Title = {{SPARQL} {Query} {Language} for {RDF}},
	Url = {https://www.w3.org/TR/rdf-sparql-query/},
	Urldate = {2020-05-23},
	Bdsk-Url-1 = {https://www.w3.org/TR/rdf-sparql-query/}
}

@misc{swift,
	Abstract = {Swift is a general-purpose programming language built using a modern approach to safety, performance, and software design patterns.},
	Author = {Inc, Apple},
	File = {Snapshot:/Users/willy/Zotero/storage/4B25VW9R/swift-compiler.html:text/html},
	Journal = {Swift.org},
	Language = {en},
	Note = {Library Catalog: swift.org},
	Title = {Swift.org},
	Url = {https://swift.org},
	Urldate = {2020-05-24},
	Bdsk-Url-1 = {https://swift.org}
}

@misc{touring-complete,
	Abstract = {In computability theory, a system of data-manipulation rules (such as a computer's instruction set, a programming language, or a cellular automaton) is said to be Turing-complete or computationally universal if it can be used to simulate any Turing machine. This means that this system is able to recognize or decide other data-manipulation rule sets. Turing completeness is used as a way to express the power of such a data-manipulation rule set. Virtually all programming languages today are Turing-complete. The concept is named after English mathematician and computer scientist Alan Turing.
	A related concept is that of Turing equivalence --  two computers P and Q are called equivalent if P can simulate Q and Q can simulate P. The Church--Turing thesis conjectures that any function whose values can be computed by an algorithm can be computed by a Turing machine, and therefore that if any real-world computer can simulate a Turing machine, it is Turing equivalent to a Turing machine. A universal Turing machine can be used to simulate any Turing machine and by extension the computational aspects of any possible real-world computer.To show that something is Turing-complete, it is enough to show that it can be used to simulate some Turing-complete system. For example, an imperative language is Turing-complete if it has conditional branching (e.g., "if" and "goto" statements, or a "branch if zero" instruction; see one-instruction set computer) and the ability to change an arbitrary amount of memory (e.g., the ability to maintain an arbitrary number of data items). Of course, no physical system can have infinite memory; but if the limitation of finite memory is ignored, most programming languages are otherwise Turing-complete.},
	Copyright = {Creative Commons Attribution-ShareAlike License},
	File = {Snapshot:/Users/willy/Zotero/storage/75BP6CG5/index.html:text/html},
	Journal = {Wikipedia},
	Language = {en},
	Month = may,
	Note = {Page Version ID: 954916159},
	Title = {Turing completeness},
	Url = {https://en.wikipedia.org/w/index.php?title=Turing_completeness&oldid=954916159},
	Urldate = {2020-05-26},
	Year = {2020},
	Bdsk-Url-1 = {https://en.wikipedia.org/w/index.php?title=Turing_completeness&oldid=954916159}
}

@misc{turtle,
	File = {Turtle - Terse RDF Triple Language:/Users/willy/Zotero/storage/7P839V2A/turtle.html:text/html},
	Title = {Turtle - {Terse} {RDF} {Triple} {Language}},
	Url = {https://www.w3.org/TeamSubmission/turtle/#sec-grammar},
	Urldate = {2020-05-23},
	Bdsk-Url-1 = {https://www.w3.org/TeamSubmission/turtle/#sec-grammar}
}

@misc{rustc,
	File = {What is rustc? - The rustc book:/Users/willy/Zotero/storage/U4NK2SK5/index.html:text/html},
	Title = {What is rustc? - {The} rustc book},
	Url = {https://doc.rust-lang.org/rustc/index.html},
	Urldate = {2020-05-24},
	Bdsk-Url-1 = {https://doc.rust-lang.org/rustc/index.html}
}

@misc{yashe,
	File = {YASHE:/Users/willy/Zotero/storage/L7BFBPFK/YASHE.html:text/html},
	Title = {{YASHE}},
	Url = {http://www.weso.es/YASHE/},
	Urldate = {2020-05-25},
	Bdsk-Url-1 = {http://www.weso.es/YASHE/}
}

@article{graph-data-model,
  title={A graph-based data model and its ramifications},
	author={Levene, Mark and Loizou, George},
  journal={IEEE Transactions on Knowledge and Data Engineering},
  volume={7},
  number={5},
  pages={809--823},
  year={1995},
  publisher={IEEE}
}

@article{big-data,
  title={Big data: A survey},
  author={Chen, Min and Mao, Shiwen and Liu, Yunhao},
  journal={Mobile networks and applications},
  volume={19},
  number={2},
  pages={171--209},
  year={2014},
  publisher={Springer}
}

@article{semantic-web,
  title={The semantic web},
  author={Berners-Lee, Tim and Hendler, James and Lassila, Ora},
  journal={Scientific american},
  volume={284},
  number={5},
  pages={34--43},
  year={2001},
  publisher={JSTOR}
}

@misc{semantic-roadmap,
  title={Semantic web road map},
  author={Berners-Lee, Tim and others},
  year={1998}
}

@book{van2003relax,
  title={Relax ng: A simpler schema language for xml},
  author={Van der Vlist, Eric},
  year={2003},
  publisher={" O'Reilly Media, Inc."}
}

@misc{fernandez2016inference,
  title={Inference and serialization of latent graph schemata using shex},
  author={Fern{\'a}ndez-Alvarez, Daniel and Labra-Gayo, Jose Emilio and Garc{\i}a-Gonz{\'a}lez, Herminio},
  year={2016},
  publisher={SEMAPRO}
}

@misc{levy1998compiler,
  title={Compiler with generic front end and dynamically loadable back ends},
  author={Levy, Jacob Y and Lim, Swee Boon and Kretsch, Donald J and Mitchell, Wesley E and Lerner, Benjamin},
  year={1998},
  month=sep # "~22",
  publisher={Google Patents},
  note={US Patent 5,812,851}
}